# backend_v2/services/sim_lab_service.py

from __future__ import annotations

import logging
import random
from datetime import datetime, timedelta
from typing import Any, Dict, List, Tuple

from sqlalchemy import Column, DateTime, Float, ForeignKey, Integer, String, func, delete
from sqlalchemy.orm import Session, declarative_base, relationship

from backend_v2.database import engine

logger = logging.getLogger("the13th.sim_lab.service")

Base = declarative_base()

# -------------------------------------------------------------------
# Simulation models (isolated from main production models)
# -------------------------------------------------------------------


class SimCompany(Base):
    __tablename__ = "sim_companies"

    id: int = Column(Integer, primary_key=True, index=True)
    name: str = Column(String(255), nullable=False)
    segment: str = Column(String(100), nullable=True)
    region: str = Column(String(100), nullable=True)
    target_volume: int = Column(Integer, nullable=True)
    created_at: datetime = Column(DateTime, default=datetime.utcnow, nullable=False)

    leads = relationship("SimLead", back_populates="company", cascade="all, delete-orphan")


class SimLead(Base):
    __tablename__ = "sim_leads"

    id: int = Column(Integer, primary_key=True, index=True)
    company_id: int = Column(Integer, ForeignKey("sim_companies.id"), nullable=False)
    full_name: str = Column(String(255), nullable=False)
    email: str = Column(String(255), nullable=False)
    status: str = Column(String(50), nullable=False)  # new, nurturing, won, lost
    stage: str = Column(String(50), nullable=False)   # top, middle, bottom
    score: int = Column(Integer, nullable=False)      # 0 - 100
    deal_value: int = Column(Integer, nullable=False)  # in dollars
    created_at: datetime = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at: datetime = Column(DateTime, default=datetime.utcnow, nullable=False)

    company = relationship("SimCompany", back_populates="leads")


class SimBurst(Base):
    __tablename__ = "sim_bursts"

    id: int = Column(Integer, primary_key=True, index=True)
    run_at: datetime = Column(DateTime, default=datetime.utcnow, nullable=False)
    leads_created: int = Column(Integer, default=0, nullable=False)
    events_generated: int = Column(Integer, default=0, nullable=False)
    notes: str = Column(String(255), nullable=True)


# -------------------------------------------------------------------
# Constants
# -------------------------------------------------------------------

SIM_DEFAULT_COMPANIES: int = 5
SIM_LEADS_PER_COMPANY: int = 250

COMPANY_PROFILES: List[Dict[str, Any]] = [
    {
        "name": "Northstar Realty Group",
        "segment": "High-volume buyer leads",
        "region": "US West",
        "target_volume": 250,
    },
    {
        "name": "Skyline Estates Collective",
        "segment": "Luxury listings & VIP buyers",
        "region": "US East",
        "target_volume": 250,
    },
    {
        "name": "Horizon Home Advisors",
        "segment": "First-time buyers & relocation",
        "region": "US South",
        "target_volume": 250,
    },
    {
        "name": "PrimeCity Realty Partners",
        "segment": "Urban condos & investors",
        "region": "US Northeast",
        "target_volume": 250,
    },
    {
        "name": "Evergreen Property Lab",
        "segment": "Suburban family homes",
        "region": "US Midwest",
        "target_volume": 250,
    },
]

LEAD_STATUSES: List[str] = ["new", "nurturing", "won", "lost"]
LEAD_STAGES: List[str] = ["top", "middle", "bottom"]


# -------------------------------------------------------------------
# Schema init
# -------------------------------------------------------------------


def ensure_sim_schema() -> None:
    """
    Ensures simulation tables exist.
    Safe and idempotent.
    """
    try:
        Base.metadata.create_all(bind=engine)
    except Exception as exc:
        logger.exception("Failed to create Simulation Lab tables: %s", exc)
        raise


# -------------------------------------------------------------------
# Helpers
# -------------------------------------------------------------------


def _generate_lead_name(idx: int, company_name: str) -> str:
    parts = company_name.split()
    base = parts[0] if parts else "Lead"
    return f"{base} Lead {idx}"


def _generate_lead_email(idx: int, company_name: str) -> str:
    slug = company_name.lower().replace(" ", "").replace("&", "and")
    return f"lead{idx}@{slug}.sim.the13th.io"


def _random_status_and_stage() -> Tuple[str, str]:
    status = random.choices(
        population=LEAD_STATUSES,
        weights=[0.45, 0.35, 0.1, 0.1],
        k=1,
    )[0]
    stage = random.choices(
        population=LEAD_STAGES,
        weights=[0.5, 0.3, 0.2],
        k=1,
    )[0]
    return status, stage


def _random_score_and_value(status: str) -> Tuple[int, int]:
    if status == "won":
        score = random.randint(75, 100)
        value = random.randint(8000, 25000)
    elif status == "nurturing":
        score = random.randint(40, 85)
        value = random.randint(5000, 18000)
    elif status == "lost":
        score = random.randint(10, 60)
        value = random.randint(3000, 15000)
    else:  # new
        score = random.randint(20, 70)
        value = random.randint(3000, 12000)
    return score, value


# -------------------------------------------------------------------
# Core Simulation Operations
# -------------------------------------------------------------------


def seed_simulation_lab(
    db: Session,
    company_count: int = SIM_DEFAULT_COMPANIES,
    leads_per_company: int = SIM_LEADS_PER_COMPANY,
) -> Dict[str, Any]:
    """
    Idempotent seeding.

    - If companies already exist AND we already have at least company_count * leads_per_company
      leads, we do nothing.
    - Otherwise:
      - create up to company_count companies (using profiles)
      - ensure each has at least leads_per_company leads.
    """

    ensure_sim_schema()

    existing_companies = db.query(SimCompany).count()
    existing_leads = db.query(SimLead).count()
    target_leads = company_count * leads_per_company

    if existing_companies >= company_count and existing_leads >= target_leads:
        logger.info(
            "Simulation Lab already seeded (companies=%s, leads=%s).",
            existing_companies,
            existing_leads,
        )
        return {
            "status": "ok",
            "message": "Simulation Lab already seeded; no changes.",
            "companies_existing": existing_companies,
            "leads_existing": existing_leads,
            "companies_created": 0,
            "leads_created": 0,
        }

    companies_created = 0
    leads_created = 0

    companies: List[SimCompany] = []

    if existing_companies == 0:
        profiles = COMPANY_PROFILES[:company_count]
        for profile in profiles:
            company = SimCompany(
                name=profile["name"],
                segment=profile.get("segment"),
                region=profile.get("region"),
                target_volume=profile.get("target_volume", leads_per_company),
            )
            db.add(company)
            companies.append(company)
            companies_created += 1

        for extra_idx in range(len(companies) + 1, company_count + 1):
            company = SimCompany(
                name=f"Simulation Company {extra_idx}",
                segment="General real estate",
                region="US",
                target_volume=leads_per_company,
            )
            db.add(company)
            companies.append(company)
            companies_created += 1

        db.flush()
    else:
        companies = db.query(SimCompany).all()

    for company in companies:
        current_count = (
            db.query(SimLead)
            .filter(SimLead.company_id == company.id)
            .count()
        )
        to_create = max(0, leads_per_company - current_count)
        if to_create <= 0:
            continue

        for i in range(current_count + 1, current_count + to_create + 1):
            status, stage = _random_status_and_stage()
            score, value = _random_score_and_value(status)
            name = _generate_lead_name(i, company.name)
            email = _generate_lead_email(i, company.name)
            created_at = datetime.utcnow() - timedelta(days=random.randint(0, 60))

            lead = SimLead(
                company_id=company.id,
                full_name=name,
                email=email,
                status=status,
                stage=stage,
                score=score,
                deal_value=value,
                created_at=created_at,
                updated_at=created_at,
            )
            db.add(lead)
            leads_created += 1

    if companies_created or leads_created:
        db.commit()

    total_companies = db.query(SimCompany).count()
    total_leads = db.query(SimLead).count()

    logger.info(
        "Simulation Lab seeded. companies_created=%s, leads_created=%s, total_companies=%s, total_leads=%s",
        companies_created,
        leads_created,
        total_companies,
        total_leads,
    )

    return {
        "status": "ok",
        "message": "Simulation Lab seeded or topped up successfully.",
        "companies_existing": existing_companies,
        "leads_existing": existing_leads,
        "companies_created": companies_created,
        "leads_created": leads_created,
        "companies_total": total_companies,
        "leads_total": total_leads,
    }


def run_simulation_burst(
    db: Session,
    leads_per_company: int = 25,
) -> Dict[str, Any]:
    """
    A single burst:
    - Adds leads_per_company new leads per company.
    - Randomly updates a slice of existing leads.
    """

    ensure_sim_schema()

    companies = db.query(SimCompany).all()
    if not companies:
        return {
            "status": "error",
            "message": "No simulation companies exist. Run /admin/sim-lab/seed first.",
        }

    new_leads = 0
    updated_leads = 0

    for company in companies:
        current_count = (
            db.query(SimLead)
            .filter(SimLead.company_id == company.id)
            .count()
        )
        start_index = current_count + 1
        end_index = current_count + leads_per_company

        for i in range(start_index, end_index + 1):
            status, stage = _random_status_and_stage()
            score, value = _random_score_and_value(status)
            name = _generate_lead_name(i, company.name)
            email = _generate_lead_email(i, company.name)

            created_at = datetime.utcnow()

            lead = SimLead(
                company_id=company.id,
                full_name=name,
                email=email,
                status=status,
                stage=stage,
                score=score,
                deal_value=value,
                created_at=created_at,
                updated_at=created_at,
            )
            db.add(lead)
            new_leads += 1

        sample_size = min(50, current_count)
        if sample_size > 0:
            sample_leads = (
                db.query(SimLead)
                .filter(SimLead.company_id == company.id)
                .order_by(func.random())
                .limit(sample_size)
                .all()
            )
            for lead in sample_leads:
                status, stage = _random_status_and_stage()
                score, value = _random_score_and_value(status)
                lead.status = status
                lead.stage = stage
                lead.score = score
                lead.deal_value = value
                lead.updated_at = datetime.utcnow()
                updated_leads += 1

    burst = SimBurst(
        run_at=datetime.utcnow(),
        leads_created=new_leads,
        events_generated=new_leads + updated_leads,
        notes="Standard simulation burst",
    )
    db.add(burst)

    db.commit()

    logger.info(
        "Simulation burst completed. new_leads=%s, updated_leads=%s",
        new_leads,
        updated_leads,
    )

    return {
        "status": "ok",
        "message": "Simulation burst completed.",
        "leads_created": new_leads,
        "leads_updated": updated_leads,
    }


def run_multiple_bursts(
    db: Session,
    burst_count: int,
    leads_per_company: int = 25,
) -> Dict[str, Any]:
    """
    Run N bursts in sequence. This is the Step C load driver.

    Returns cumulative stats across all bursts.
    """

    burst_count = max(1, min(burst_count, 50))  # hard cap to keep it safe

    total_new = 0
    total_updated = 0

    for i in range(burst_count):
        result = run_simulation_burst(db, leads_per_company=leads_per_company)
        if result.get("status") != "ok":
            return {
                "status": "error",
                "message": f"Stopped at burst {i + 1}: {result.get('message', 'unknown error')}",
                "leads_created": total_new,
                "leads_updated": total_updated,
                "bursts_completed": i,
            }
        total_new += int(result.get("leads_created", 0))
        total_updated += int(result.get("leads_updated", 0))

    logger.info(
        "Multiple bursts completed. bursts=%s, total_new=%s, total_updated=%s",
        burst_count,
        total_new,
        total_updated,
    )

    return {
        "status": "ok",
        "message": f"{burst_count} simulation bursts completed.",
        "leads_created": total_new,
        "leads_updated": total_updated,
        "bursts_completed": burst_count,
    }


def reset_simulation_lab(db: Session) -> Dict[str, Any]:
    """
    Hard reset of Simulation Lab:
    - Deletes all bursts
    - Deletes all leads
    - Deletes all companies

    Does NOT touch any production tables.
    """

    ensure_sim_schema()

    leads_deleted = db.query(SimLead).delete()
    bursts_deleted = db.query(SimBurst).delete()
    companies_deleted = db.query(SimCompany).delete()
    db.commit()

    logger.warning(
        "Simulation Lab reset. companies_deleted=%s, leads_deleted=%s, bursts_deleted=%s",
        companies_deleted,
        leads_deleted,
        bursts_deleted,
    )

    return {
        "status": "ok",
        "message": "Simulation Lab reset to baseline.",
        "companies_deleted": companies_deleted,
        "leads_deleted": leads_deleted,
        "bursts_deleted": bursts_deleted,
    }


def get_simulation_overview(db: Session) -> Dict[str, Any]:
    """
    Aggregated metrics for the Simulation Master Dashboard.
    """

    ensure_sim_schema()

    companies_count = db.query(SimCompany).count()
    leads_count = db.query(SimLead).count()

    status_rows = (
        db.query(SimLead.status, func.count(SimLead.id))
        .group_by(SimLead.status)
        .all()
    )
    deal_distribution = {status: count for status, count in status_rows}

    scoring_buckets = {"0-20": 0, "21-40": 0, "41-60": 0, "61-80": 0, "81-100": 0}
    for score, count in (
        db.query(SimLead.score, func.count(SimLead.id))
        .group_by(SimLead.score)
        .all()
    ):
        if score <= 20:
            scoring_buckets["0-20"] += count
        elif score <= 40:
            scoring_buckets["21-40"] += count
        elif score <= 60:
            scoring_buckets["41-60"] += count
        elif score <= 80:
            scoring_buckets["61-80"] += count
        else:
            scoring_buckets["81-100"] += count

    burst_count = db.query(SimBurst).count()
    totals = (
        db.query(
            func.coalesce(func.sum(SimBurst.leads_created), 0),
            func.coalesce(func.sum(SimBurst.events_generated), 0),
        )
        .one()
    )
    leads_from_bursts, events_generated = totals

    won_leads = db.query(SimLead).filter(SimLead.status == "won").all()
    deviations: List[float] = []
    for lead in won_leads:
        expected_score = 85.0
        deviations.append(abs(float(lead.score) - expected_score))

    forecast_accuracy_deviation = (
        sum(deviations) / len(deviations) if deviations else 0.0
    )

    overview = {
        "status": "ok",
        "companies_seeded": companies_count,
        "lead_count": leads_count,
        "deal_distribution": deal_distribution,
        "scoring_distribution": scoring_buckets,
        "event_throughput": {
            "bursts": burst_count,
            "leads_created_in_bursts": int(leads_from_bursts or 0),
            "events_generated": int(events_generated or 0),
        },
        "forecast_accuracy_deviation": round(float(forecast_accuracy_deviation), 2),
        "simulation_bursts_processed": burst_count,
    }

    return overview
