# backend_v2/routers/client_experience_sim.py
from __future__ import annotations

import logging
from math import ceil
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from fastapi import APIRouter, Depends, Query, Request
from fastapi.responses import HTMLResponse
from sqlalchemy.orm import Session

from backend_v2.database import get_db
from backend_v2.services.auth_service import authenticated_admin
from backend_v2.services.render import render_template
from backend_v2.sim_client_engine import run_client_simulation, get_available_personas
from backend_v2.services.client_experience_insights import build_revealable_insights, build_comparison_differences


from backend_v2.services.client_experience_metrics import (
    compute_kpis,
    JourneyEvent,
)

logger = logging.getLogger("the13th.client_experience_sim")

router = APIRouter(
    prefix="/admin/client-experience",
    tags=["Client Experience Simulation"],
)

# ---------------------------------------------------------------------------
# SUMMARY BUILDER
# ---------------------------------------------------------------------------


def compute_client_experience_summary(
    simulation: Optional[Dict[str, Any]]
) -> Dict[str, Any]:
    summary: Dict[str, Any] = {
        "lead_profile": {
            "label": "Not enough data yet",
            "summary": "Run a 30-day simulation to profile this lead.",
            "rhythm": "—",
        },
        "assistant_pattern": {
            "label": "No pattern detected yet",
            "summary": "Assistant behaviour will be summarised after at least a few messages.",
        },
        "journey": {
            "start_stage": "—",
            "end_stage": "—",
            "path": "",
            "days": 0,
        },
        "metrics": {
            "convert_prob": 0.0,
            "dropoff_prob": 0.0,
            "intensity_score": 0.0,
        },
    }

    if not simulation or not isinstance(simulation, dict):
        return summary

    events = simulation.get("events") or []
    if not isinstance(events, list) or not events:
        return summary

    days_seen = set()
    client_msgs = 0
    assistant_msgs = 0
    stages: List[str] = []

    for ev in events:
        if not isinstance(ev, dict):
            continue

        day = ev.get("day") or ev.get("day_index") or ev.get("d")
        if day is not None:
            days_seen.add(day)

        stage = ev.get("stage_after") or ev.get("stage") or ""
        if stage and (not stages or stages[-1] != stage):
            stages.append(str(stage))

        sender_raw = (
            ev.get("actor") or ev.get("sender") or ev.get("from") or ""
        ).lower()
        if sender_raw in {"lead", "client", "buyer", "prospect"}:
            client_msgs += 1
        elif sender_raw in {"assistant", "agent", "ai", "system"}:
            assistant_msgs += 1

    total_msgs = client_msgs + assistant_msgs
    days_count = max(len(days_seen), 1)

    # Lead profile
    if client_msgs == 0:
        lead_label = "Silent / unresponsive"
        rhythm = "No replies observed yet."
    elif client_msgs <= ceil(days_count * 0.3):
        lead_label = "Low-frequency responder"
        rhythm = "Occasional replies with long gaps."
    elif client_msgs <= ceil(days_count * 0.7):
        lead_label = "Steady engager"
        rhythm = "Regular replies across the journey."
    else:
        lead_label = "High-intent, high-engagement"
        rhythm = "Very active throughout the journey."

    summary["lead_profile"]["label"] = lead_label
    summary["lead_profile"]["rhythm"] = rhythm
    summary["lead_profile"]["summary"] = (
        f"{client_msgs} client messages over {days_count} day(s)."
    )

    # Assistant pattern
    if assistant_msgs == 0:
        assist_label = "Assistant has not engaged yet"
        assist_summary = "No outbound messages from the assistant were recorded."
    else:
        ratio = assistant_msgs / max(client_msgs, 1)
        if ratio < 0.8:
            assist_label = "Conservative follow-up"
            assist_summary = "Assistant replied selectively."
        elif ratio <= 1.5:
            assist_label = "Balanced follow-up"
            assist_summary = "Assistant maintained a healthy reply rhythm."
        else:
            assist_label = "High-touch assistant"
            assist_summary = "Assistant followed up aggressively."

    summary["assistant_pattern"]["label"] = assist_label
    summary["assistant_pattern"]["summary"] = (
        assist_summary + f" ({assistant_msgs} messages from assistant.)"
    )

    if stages:
        summary["journey"]["start_stage"] = stages[0]
        summary["journey"]["end_stage"] = stages[-1]
        summary["journey"]["path"] = (
            " → ".join(stages) if len(stages) > 1 else stages[0]
        )

    summary["journey"]["days"] = days_count

    # Probability heuristics
    end_stage_lower = str(summary["journey"]["end_stage"]).lower()
    high_intent_keywords = ["high intent", "hot", "engaged", "active", "under contract"]
    converted_keywords = ["won", "closed won", "converted"]

    convert_prob = 0.1
    drop_prob = 0.3

    if any(k in end_stage_lower for k in converted_keywords):
        convert_prob = 0.95
        drop_prob = 0.02
    elif any(k in end_stage_lower for k in high_intent_keywords):
        convert_prob = 0.75
        drop_prob = 0.15
    elif "cold" in end_stage_lower or "lost" in end_stage_lower:
        convert_prob = 0.15
        drop_prob = 0.7
    else:
        if client_msgs >= days_count:
            convert_prob = 0.55
            drop_prob = 0.25
        elif client_msgs == 0:
            convert_prob = 0.05
            drop_prob = 0.8
        else:
            convert_prob = 0.35
            drop_prob = 0.4

    intensity = min(1.0, total_msgs / float(days_count * 4))

    summary["metrics"]["convert_prob"] = round(convert_prob, 2) * 100.0
    summary["metrics"]["dropoff_prob"] = round(drop_prob, 2) * 100.0
    summary["metrics"]["intensity_score"] = round(intensity * 100.0, 1)

    return summary


# ---------------------------------------------------------------------------
# NARRATIVE BUILDER
# ---------------------------------------------------------------------------


def build_narrative_summary(summary: Dict[str, Any]) -> str:
    lp = summary.get("lead_profile", {})
    ap = summary.get("assistant_pattern", {})
    jr = summary.get("journey", {})
    mt = summary.get("metrics", {})

    lead_label = lp.get("label", "the lead")
    rhythm = lp.get("rhythm", "")
    assist_label = ap.get("label", "the assistant")
    assist_summary = ap.get("summary", "")

    start_stage = jr.get("start_stage", "—")
    end_stage = jr.get("end_stage", "—")
    path = jr.get("path", "")
    days = jr.get("days", 0)

    convert_prob = mt.get("convert_prob", 0)
    drop_prob = mt.get("dropoff_prob", 0)
    intensity = mt.get("intensity_score", 0)

    narrative = (
        f"This simulated client exhibited **{lead_label.lower()}** behaviour over "
        f"a **{days}-day** journey. Rhythm: _{rhythm}_.\n\n"
        f"The assistant showed **{assist_label.lower()}** behaviour "
        f"— _{assist_summary}_\n\n"
    )

    if path:
        narrative += (
            f"Journey path: **{path}** (from {start_stage} → {end_stage}).\n\n"
        )

    narrative += (
        f"Engagement intensity: **{intensity}%**.\n\n"
        f"Estimated conversion probability: **{convert_prob}%**, "
        f"drop-off risk: **{drop_prob}%**."
    )

    return narrative


# ---------------------------------------------------------------------------
# DECISION TREE
# ---------------------------------------------------------------------------


def build_decision_tree(
    simulation: Optional[Dict[str, Any]]
) -> List[Dict[str, str]]:
    if not simulation or "events" not in simulation:
        return []

    events = simulation.get("events", [])
    decisions = []

    for ev in events:
        if not isinstance(ev, dict):
            continue

        day = ev.get("day") or ev.get("day_index") or ev.get("d") or 0
        sender = (ev.get("actor") or ev.get("sender") or ev.get("from") or "").lower()
        content = ev.get("text") or ev.get("message") or ""

        stage_before = ev.get("stage_before") or ev.get("stage") or ""
        stage_after = ev.get("stage_after") or stage_before

        explanation = None

        if sender in {"lead", "client", "prospect", "buyer"}:
            explanation = (
                "Lead sent a short message → light follow-up cadence."
                if len(content) < 40
                else "Lead sent a detailed message → assistant escalated engagement."
            )
        elif sender in {"assistant", "agent", "ai"}:
            if "?" in content:
                explanation = "Assistant prompted the lead with a question."
            elif "follow" in content.lower():
                explanation = "Assistant executed scheduled follow-up."
            else:
                explanation = "Routine assistant touchpoint."

        if stage_after != stage_before:
            explanation = (
                f"Stage shift: **{stage_before} → {stage_after}**. "
                f"Assistant adapted strategy."
            )

        if explanation:
            decisions.append({"day": day, "explanation": explanation})

    decisions.sort(key=lambda x: x["day"])
    return decisions


# ---------------------------------------------------------------------------
# MAIN ROUTE — WITH REAL KPI STRIP
# ---------------------------------------------------------------------------


@router.get("", response_class=HTMLResponse)
def client_experience_page(
    request: Request,
    persona: str = Query("hot_lead"),
    days: int = Query(30, ge=7, le=60),
    db: Session = Depends(get_db),
    admin: Any = Depends(authenticated_admin),
) -> HTMLResponse:
    try:
        personas = get_available_personas()
    except Exception as exc:
        logger.exception("Error fetching personas: %s", exc)
        personas = []

    simulation: Optional[Dict[str, Any]] = None
    try:
        simulation = run_client_simulation(days=days, persona_key=persona)

        graphs = (simulation or {}).get("graphs", None)
        if isinstance(graphs, list):
            named = {}
            for g in graphs:
                label = (
                    (g.get("label") or "")
                    .lower()
                    .replace(" ", "_")
                    .replace("-", "_")
                )
                if label:
                    named[label] = g
            simulation["graphs"] = named

    except Exception as exc:
        logger.exception("Error generating client simulation: %s", exc)
        simulation = None

    summary = compute_client_experience_summary(simulation)
    narrative = build_narrative_summary(summary)
    decision_tree = build_decision_tree(simulation)


    revealable_insights = build_revealable_insights(simulation, summary)



@router.get("/compare", response_class=HTMLResponse)
def client_experience_compare_page(
    request: Request,
    persona_a: str = Query("hot_lead"),
    persona_b: str = Query("slow_burner"),
    days: int = Query(30, ge=7, le=60),
    db: Session = Depends(get_db),
    admin: Any = Depends(authenticated_admin),
) -> HTMLResponse:
    """
    Comparison mode: run two personas side by side and show a hybrid comparison.
    """

    try:
        personas = get_available_personas()
    except Exception as exc:
        logger.exception("Error fetching personas for compare: %s", exc)
        personas = []

    # Run simulations
    sim_a = None
    sim_b = None
    try:
        sim_a = run_client_simulation(days=days, persona_key=persona_a)
        sim_b = run_client_simulation(days=days, persona_key=persona_b)
    except Exception as exc:
        logger.exception("Error running comparison simulations: %s", exc)

    summary_a = compute_client_experience_summary(sim_a)
    summary_b = compute_client_experience_summary(sim_b)

    insights_a = build_revealable_insights(sim_a, summary_a)
    insights_b = build_revealable_insights(sim_b, summary_b)

    # Comparison difference engine
    label_a = persona_a
    label_b = persona_b
    comparison = build_comparison_differences(
        sim_a, summary_a, sim_b, summary_b, label_a=label_a, label_b=label_b
    )

    context = {
        "request": request,
        "personas": personas,
        "persona_a": persona_a,
        "persona_b": persona_b,
        "days": days,
        "sim_a": sim_a,
        "sim_b": sim_b,
        "summary_a": summary_a,
        "summary_b": summary_b,
        "insights_a": insights_a,
        "insights_b": insights_b,
        "comparison": comparison,
    }

    return render_template("admin_sim_client_compare.html", context)



# -----------------------------------------------------------
# STEP 2 — BUILD JOURNEY EVENTS FOR KPI STRIP
# -----------------------------------------------------------
    journey_events: List[JourneyEvent] = []
    base_dt = datetime.utcnow()

    if simulation and "events" in simulation:
        events = simulation["events"]
        for idx, ev in enumerate(events):
            if not isinstance(ev, dict):
                continue

            # 1. Try explicit timestamp
            ts = ev.get("timestamp") or ev.get("ts")

            # 2. If missing, synthesize from day index + sequence
            if not ts:
                day_idx = (
                    ev.get("day") or ev.get("day_index") or ev.get("d") or 0
                )
                try:
                    day_idx_int = int(day_idx)
                except Exception:
                    day_idx_int = 0

                # Spread events 10 minutes apart within each day
                ts = base_dt + timedelta(
                    days=day_idx_int, minutes=idx * 10
                )
            else:
                # Parse string/other formats into datetime
                if isinstance(ts, str):
                    try:
                        ts = datetime.fromisoformat(ts)
                    except Exception:
                        # If string format is unknown, fallback to day-based synthesis
                        day_idx = (
                            ev.get("day") or ev.get("day_index") or ev.get("d") or 0
                        )
                        # safeguard fallback
                        try:
                            day_idx_int = int(day_idx)
                        except Exception:
                            day_idx_int = 0
                        ts = base_dt + timedelta(
                            days=day_idx_int, minutes=idx * 10
                        )

            sender = (
                ev.get("actor") or ev.get("sender") or ev.get("from") or ""
            ).lower()

            if sender in {"lead", "client", "buyer", "prospect"}:
                journey_events.append(
                    JourneyEvent(timestamp=ts, direction="client")
                )
            elif sender in {"assistant", "agent", "ai", "system"}:
                journey_events.append(
                    JourneyEvent(timestamp=ts, direction="assistant")
                )

    kpis = compute_kpis(journey_events)

# -----------------------------------------------------------
# STEP 3 UPGRADED — Stage Markers (clean, deduped)
# -----------------------------------------------------------
    stage_markers = []
    last_stage = None
    total_days = max(days, 1)

    try:
        if simulation and "events" in simulation:
            for ev in simulation["events"]:

                stage_after = ev.get("stage_after") or ev.get("stage")
                if not stage_after:
                    continue

                # Only mark when the stage actually changes
                if stage_after == last_stage:
                    continue

                last_stage = stage_after

                # Day index
                day_idx = ev.get("day") or ev.get("day_index") or ev.get("d") or 0
                try:
                    d = int(day_idx)
                except:
                    d = 0

                x_pct = (d / total_days) * 100

                # Abbreviate long stage labels
                short_label = {
                    "Engaged": "Eng",
                    "Warm": "Wrm",
                    "Active": "Actv",
                    "Hot": "Hot",
                    "High Intent": "HI",
                    "Under Contract": "UC",
                    "Contract": "UC",
                    "Converted": "Conv",
                    "Lost": "Lost"
                }.get(stage_after, stage_after[:6])

                stage_markers.append({
                    "day": d,
                    "stage": short_label,
                    "x_pct": x_pct,
                })
    except Exception as exc:
        logger.exception("Error generating stage markers: %s", exc)


    # KPI strip summarized stats
    kpi_strip = {
        "avg_response_delay_label": kpis.avg_response_delay_label,
        "longest_gap_label": kpis.longest_gap_label,
        "intensity_score": kpis.intensity_score,
        "total_touchpoints": kpis.total_touchpoints,
    }

    # -----------------------------------------------------------
    # RENDER
    # -----------------------------------------------------------
    context = {
        "request": request,
        "personas": personas,
        "persona": persona,
        "days": days,
        "simulation": simulation,
        "summary": summary,
        "narrative": narrative,
        "decision_tree": decision_tree,
        "kpi_strip": kpi_strip,
        "stage_markers": stage_markers,
        "insights": revealable_insights,
    }

    return render_template("admin_sim_client_experience.html", context)


@router.get("/client-experience/compare", response_class=HTMLResponse)
def compare_client_experience(request: Request, persona_a: str, persona_b: str, days: int = 30, db: Session = Depends(get_db)):
    sim_a = run_client_simulation(persona=persona_a, days=days, db=db)
    sim_b = run_client_simulation(persona=persona_b, days=days, db=db)

    summary_a = compute_client_experience_summary(sim_a)
    summary_b = compute_client_experience_summary(sim_b)

    insights_a = build_revealable_insights(sim_a, summary_a)
    insights_b = build_revealable_insights(sim_b, summary_b)

    return render_template(
        "admin_sim_client_compare.html",
        {
            "sim_a": sim_a,
            "sim_b": sim_b,
            "summary_a": summary_a,
            "summary_b": summary_b,
            "insights_a": insights_a,
            "insights_b": insights_b,
            "persona_a": persona_a,
            "persona_b": persona_b,
            "days": days,
        },
    )
